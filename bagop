#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use File::Basename;
use File::Temp;
use Getopt::Long qw(:config bundling); 
use Storable;
use Sys::Hostname;
use Text::Abbrev;

my ($prg_name, $host_name, $usage);

$prg_name  = File::Basename::basename($0);
$host_name = (split /\./, Sys::Hostname::hostname)[0];

# >>>>>>>>>>>>>>>>>>>>>>>>>>> OPTIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<

my ($abr_hash, $cmd);

Getopt::Long::GetOptions(
    "dest|dst=s"       => \$opt::dest,
    "dryrun|dry-run|d" => \$opt::dryrun,
    "quiet|q"          => \$opt::quiet,
);

set_dest();

$abr_hash = Text::Abbrev::abbrev qw(add delete commit status);
$cmd      = shift @ARGV       or ::exit_usage();

$cmd         = $abr_hash->{$cmd} or ::exit_usage();

if ($cmd eq "add") {
    bagop_add(\@ARGV);
} elsif ($cmd eq "delete") {
    bagop_delete(\@ARGV);
} elsif ($cmd eq "commit") {
    bagop_commit()
} elsif ($cmd eq "status") {
    bagop_status();
} else {
    die "This should not happen";
} 

# >>>>>>>>>>>>>>>>>>>>>>>>>>> SUBROUTINES <<<<<<<<<<<<<<<<<<<<<<<<<<<

# Set and check the --dest dir
sub set_dest
{
    $opt::dest ||= "$ENV{'HOME'}/backup/bagop";

    if($opt::dest =~ /:$/)
    {
        # --dest host: => host:.
        $opt::dest .= ".";
    }

    unless (-d $opt::dest)
    {
        ::error(qq(ERROR: --dest $opt::dest: No such file or directory\n));
    }
}

# Print usage and exit.
sub exit_usage
{
    my $usage = qq($prg_name [--dest [[user@]host:][dir] ] [--dryrun|-d] [--quiet|-q] \(add files|del files|commit|stat\)

type 'man $prg_name' for help.
);

    print STDERR $usage;
    exit(1);
}

# Add files to backup.
sub bagop_add
{
    my ($paths,   # List of paths to add.
    ) = @_;

    my ($db, $path, $abs_path);

    $db = db_retrieve();

    foreach $path (@{$paths}) {
        $abs_path = File::Spec->rel2abs($path);
        if (exists $db->{$abs_path}) {
            ::warning(qq(File already in backup -> $abs_path\n));
        } elsif (-l $abs_path) {
            ::warning(qq(Skipping symbolic link -> $abs_path\n));
        } elsif (! -r $abs_path) {
            ::warning(qq(Permission denied -> $abs_path\n));
        } elsif (-f $abs_path or -d $abs_path) {
            $db->{$abs_path} = {lstat => [lstat($abs_path)], status => 'NEW'};
            print STDERR qq(Added $abs_path\n) unless $opt::quiet;
        } else {
            ::error(qq{No such file or direcotry -> "$abs_path"\n});
        }
    }
    db_store($db);
}

# Delete a file from backup.
sub bagop_delete
{
    my ($paths,      # List of paths to delete.
    ) = @_;

    my ($db, $path, $abs_path);

    $db = db_retrieve();

    foreach $path (@{$paths})
    {
        $abs_path = File::Spec->rel2abs($path);

        if (exists $db->{$abs_path}) {
            delete $db->{$abs_path};
            print STDERR qq(Deleted $abs_path\n) unless $opt::quiet;
        }
        else {
            ::warning(qq(Warning! No such file or directory -> "$abs_path"\n));
        }
    }

    db_store($db);
}

# Backup files.
sub bagop_commit
{
    my ($fh, $file, $db, $tmp_fh, $tmp_file, @files, $verbose, $dryrun, @cmd);

    $db = db_retrieve();
    ($tmp_fh, $tmp_file) = File::Temp::tempfile(UNLINK => 1);
    @files = sort keys %{$db};

    map { print $tmp_fh "$_\n" if (-f $_ or -d $_) } @files;

    $verbose = $opt::quiet ? "" : "--verbose";
    $dryrun  = $opt::dryrun ? "--dry-run" : "";
    @cmd     = "rsync $verbose $dryrun --recursive --relative --update --files-from=$tmp_file / $opt::dest";

    system(@cmd) == 0 or ::error(qq(Command -> @cmd failed: $?));

    unless ($opt::dryrun)
    {
        foreach $file (@files)
        {
            $db->{$file}->{'lstat'}  = [lstat($file)];
            $db->{$file}->{'status'} = 'OK';
        }
    }

    db_store($db);
    db_commit();
}

# Collect and print backup stats.
sub bagop_status
{
    my ($db, @paths, $path, $rel_path, @stats_old, @stats_new, $size_old,
        $size_new, $mtime_old, $mtime_new, $status, $time, $tot_all, $tot_size,
        $tot_new, $tot_ok, $tot_old, $tot_mis, $size);

    $tot_all  = 0;
    $tot_size = 0;
    $tot_new  = 0;
    $tot_ok   = 0;
    $tot_old  = 0;
    $tot_mis  = 0;

    $db = db_retrieve();

    @paths = sort keys %{$db};

    printf("%-10s %-25s %8s %8s\n", "Status", "Last modified", "Size", "Path");

    foreach $path (@paths)
    {
        $rel_path = File::Spec->abs2rel($path);

        next if $rel_path =~ /^\.\./; # Skipping any parent paths

        $status    = $db->{$path}->{'status'};
        @stats_old = @{$db->{$path}->{'lstat'}};
        $size_old  = $stats_old[7];
        $mtime_old = $stats_old[9];

        if (-f $path or -d $path)
        {
            @stats_new = lstat($path);
            $size_new  = $stats_new[7];
            $mtime_new = $stats_new[9];

            if ($status eq 'NEW')
            {
                $tot_new++;
            }
            elsif ($size_old == $size_new and $mtime_old == $mtime_new)
            {
                $status = "OK";
                $tot_ok++;
            }
            else
            {
                $status = "OLD";
                $tot_old++;
            }

            $size = $size_new;
            $time = scalar localtime $mtime_new;
        }
        else
        {
            $status = "MIS";
            $tot_mis++;

            $time = scalar localtime $mtime_old;
            $size = $size_old;
        }

        printf("%-10s %-25s % 8s     %s\n", $status, $time, $size, $rel_path);

        $tot_size += $size;
        $tot_all++;
    }

    print "\n";
    printf("Total files:     %10d\n", $tot_all);
    printf("Total OK files:  %10d\n", $tot_ok);
    printf("Total NEW files: %10d\n", $tot_new);
    printf("Total OLD files: %10d\n", $tot_old);
    printf("Total MIS files: %10d\n", $tot_mis);
    printf("Total size:      %10d\n", $tot_size);
}

# Store the backup db to file.
sub db_store
{
    my ($db,         # Data
    ) = @_;

    Storable::lock_store($db, db_filename());
}

# Commit the back using rsync.
sub db_commit
{
    my ($basefile, $cachedir, $dbfile);

    $basefile = $opt::dest;
    $basefile =~ s/[^a-z0-9]/_/gi;
    $cachedir = $ENV{'HOME'}."/.bagop/cache";
    $dbfile   = "$cachedir/$basefile";

    system("rsync $dbfile $opt::dest/.$basefile 2>/dev/null;");
}

# Get database file name.
sub db_filename
{
    my ($basefile, $cachedir, $dbfile);

    $basefile = $opt::dest;
    $basefile =~ s/[^a-z0-9]/_/gi;
    $cachedir = $ENV{'HOME'}."/.bagop/cache";
    $dbfile = "$cachedir/$basefile";

    unless (-f $dbfile) {
        system("mkdir -p $cachedir; rsync $opt::dest/.$basefile $dbfile 2>/dev/null;");
    }

    return $dbfile;
}

# Retrieve the backup db from file.
sub db_retrieve
{
    my ($dbfile, $db);

    $dbfile = db_filename();
    $db     = (-f $dbfile) ? Storable::lock_retrieve($dbfile) : {};

    return wantarray ? %{$db} : $db;
}

# Output a warning.
sub warning
{
    my ($warning,   # warning message.
    ) = @_;

    my ($fh, $prog);

    $fh   = $Global::original_stderr || *STDERR;
    $prog = $Global::progname || $prg_name;

    print $fh $prog, ": Warning: ", $warning;
}

# Output an error and exit.
sub error
{
    my ($error,   # error message.
    ) = @_;

    my ($fh, $prog);

    $fh   = $Global::original_stderr || *STDERR;
    $prog = $Global::progname || $prg_name;

    print $fh $prog, ": Error: ", $error;

    exit(1);
}
